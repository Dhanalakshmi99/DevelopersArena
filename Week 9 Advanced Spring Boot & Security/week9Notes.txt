
								üìö Theory Concepts:
===============================================================================================================================
1. Spring Security Architecture
Authentication vs Authorization
Authentication

Who are you?
Verifies user identity (username/password, OAuth login, JWT, etc.)

Key classes

Authentication

AuthenticationManager

UserDetailsService

PasswordEncoder

Example

@Service
public class CustomUserDetailsService implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) {
        return User.withUsername(username)
                .password("$2a$10$abc...") // bcrypt hash
                .roles("USER")
                .build();
    }
}

Authorization

What are you allowed to do?
Checks roles/permissions after authentication.

Examples

URL-based security

Method-level security

Role-based access

http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
    .anyRequest().authenticated()
);

2. JWT Token Implementation
Access Token

Short-lived (5‚Äì15 minutes)

Sent with every request

Stored in memory or Authorization header

Refresh Token

Long-lived (days/weeks)

Used to get new access tokens

Stored securely (DB or HttpOnly cookie)

JWT Generation Example
String token = Jwts.builder()
    .setSubject(username)
    .claim("role", "USER")
    .setIssuedAt(new Date())
    .setExpiration(new Date(System.currentTimeMillis() + 900000))
    .signWith(secretKey)
    .compact();

JWT Validation Filter
public class JwtFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) {
        String token = request.getHeader("Authorization");

        if (token != null && token.startsWith("Bearer ")) {
            String username = extractUsername(token.substring(7));
            SecurityContextHolder.getContext()
                .setAuthentication(auth(username));
        }
        filterChain.doFilter(request, response);
    }
}

3. Role-Based Access Control (RBAC)
Concept

Users ‚Üí Roles ‚Üí Permissions

Common roles

ROLE_USER

ROLE_ADMIN

ROLE_MANAGER

Entity Example
@Entity
class User {
    @Id
    Long id;
    String username;

    @ManyToMany(fetch = FetchType.EAGER)
    Set<Role> roles;
}

Securing Endpoints
@GetMapping("/admin")
@PreAuthorize("hasRole('ADMIN')")
public String adminOnly() {
    return "Admin access";
}

4. Method-Level Security

Enable it:

@EnableMethodSecurity

@PreAuthorize

Checks before method execution.

@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) { }

@PostAuthorize

Checks after method execution.

@PostAuthorize("returnObject.owner == authentication.name")
public Document getDocument(Long id) {
    return document;
}

SpEL Expressions
hasRole('ADMIN')
hasAuthority('READ_PRIVILEGE')
#id == authentication.principal.id

5. OAuth2 Integration (Google, GitHub)
Purpose

Social login

No password management

Delegated authentication

Dependency
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: xxx
            client-secret: yyy

Security Config
http
  .oauth2Login(oauth -> oauth
      .defaultSuccessUrl("/home", true)
  );

6. API Rate Limiting
Purpose

Prevent abuse

Prevent brute-force attacks

Protect system resources

Bucket4j Example
Bucket bucket = Bucket4j.builder()
    .addLimit(Bandwidth.simple(10, Duration.ofMinutes(1)))
    .build();

Filter Example
if (bucket.tryConsume(1)) {
    filterChain.doFilter(request, response);
} else {
    response.setStatus(429);
}

7. Security Best Practices
Input Validation
@NotBlank
@Email
private String email;

SQL Injection Prevention

Use JPA / Prepared Statements

@Query("SELECT u FROM User u WHERE u.email = :email")
User findByEmail(@Param("email") String email);

XSS Protection

Escape output

Use CSP headers

http.headers(headers ->
    headers.contentSecurityPolicy("default-src 'self'")
);

CSRF Protection

Enabled by default:

http.csrf(Customizer.withDefaults());


Disable for APIs:

http.csrf(csrf -> csrf.disable());

8. Auditing and Logging
Why?

Detect attacks

Compliance

Debug security issues

Enable Auditing
@EnableJpaAuditing

Audited Entity
@CreatedDate
private LocalDateTime createdAt;

@LastModifiedDate
private LocalDateTime updatedAt;

Security Event Logging
@Component
public class AuthEventListener {
    @EventListener
    public void onSuccess(AuthenticationSuccessEvent event) {
        log.info("Login success: " + event.getAuthentication().getName());
    }
}

What to Log

‚úÖ Login attempts
‚úÖ Token expiration
‚úÖ Access denied
‚ùå Passwords
‚ùå JWT secrets

Summary Table
Topic	Purpose
Authentication	Verify identity
Authorization	Control access
JWT	Stateless security
RBAC	Role-based access
Method Security	Fine-grained control
OAuth2	Social login
Rate Limiting	Abuse prevention
Best Practices	Secure coding
Auditing	Monitoring & compliance
===================================================================================================================================
								üõ†Ô∏è Hands-On Practice:
==================================================================================================================================
1. JWT Authentication with Refresh Token Rotation
Notes

Access Token

Short-lived (5‚Äì15 min)

Used for API access

Refresh Token

Long-lived

Stored in DB

Rotated: old refresh token is invalidated after use

Prevents token replay attacks

Flow

User logs in ‚Üí access + refresh token issued

Access token expires

Refresh token sent ‚Üí new access + new refresh token generated

Old refresh token revoked

Refresh Token Entity
@Entity
class RefreshToken {
    @Id
    @GeneratedValue
    private Long id;

    private String token;
    private String username;
    private boolean revoked;
    private Instant expiryDate;
}

Refresh Token Rotation
public TokenResponse refresh(String oldToken) {
    RefreshToken token = repo.findByToken(oldToken)
        .orElseThrow();

    if (token.isRevoked() || token.getExpiryDate().isBefore(Instant.now()))
        throw new RuntimeException("Invalid refresh token");

    token.setRevoked(true);
    repo.save(token);

    String newRefresh = generateRefreshToken();
    String newAccess = generateAccessToken(token.getUsername());

    repo.save(new RefreshToken(newRefresh, token.getUsername()));

    return new TokenResponse(newAccess, newRefresh);
}

2. Role-Based Access Control (RBAC)
Notes

Users have roles

Roles grant permissions

Spring expects roles as ROLE_XXX

Entities
@Entity
class Role {
    @Id
    private String name; // ROLE_ADMIN, ROLE_USER
}

@Entity
class User {
    @ManyToMany(fetch = FetchType.EAGER)
    private Set<Role> roles;
}

URL-Level RBAC
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .requestMatchers("/user/**").hasAnyRole("USER","ADMIN")
    .anyRequest().authenticated()
);

3. Method-Level Security
Notes

Fine-grained access control

Uses SpEL expressions

Works after authentication

Enable It
@EnableMethodSecurity

@PreAuthorize
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) {}

@PostAuthorize
@PostAuthorize("returnObject.owner == authentication.name")
public Document getDocument(Long id) {
    return document;
}

Common Expressions
hasRole('ADMIN')
hasAuthority('READ_PRIVILEGE')
#id == authentication.principal.id

4. OAuth2 Login with Google / GitHub
Notes

Delegated authentication

No password handling

OAuth provider verifies user identity

Dependency
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: xxx
            client-secret: yyy
          github:
            client-id: xxx
            client-secret: yyy

Security Config
http.oauth2Login(oauth ->
    oauth.defaultSuccessUrl("/login/success", true)
);

Custom OAuth User
public class CustomOAuth2UserService
    extends DefaultOAuth2UserService {
}

5. API Rate Limiting with Resilience4j
Notes

Prevent brute force & abuse

Applied per endpoint or per user/IP

Dependency
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-ratelimiter</artifactId>
</dependency>

RateLimiter Config
RateLimiterConfig config = RateLimiterConfig.custom()
    .limitForPeriod(10)
    .limitRefreshPeriod(Duration.ofSeconds(60))
    .build();

Controller Example
@RateLimiter(name = "apiLimiter")
@GetMapping("/api/data")
public String data() {
    return "secured data";
}

application.yml
resilience4j.ratelimiter:
  instances:
    apiLimiter:
      limit-for-period: 10
      limit-refresh-period: 60s

6. Security Headers & CORS Configuration
Notes

Prevent XSS, clickjacking, MITM

Required for frontend-backend communication

Security Headers
http.headers(headers -> headers
    .contentSecurityPolicy(csp ->
        csp.policyDirectives("default-src 'self'"))
    .frameOptions(frame -> frame.deny())
);

CORS Config
@Bean
CorsConfigurationSource corsSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:3000"));
    config.setAllowedMethods(List.of("GET","POST","PUT","DELETE"));
    config.setAllowedHeaders(List.of("*"));

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);
    return source;
}

7. Audit Logs for Security Events
Notes

Track authentication & authorization events

Important for compliance and attack detection

Enable Auditing
@EnableJpaAuditing

Audited Fields
@CreatedDate
private Instant createdAt;

@LastModifiedDate
private Instant updatedAt;

Authentication Events
@Component
public class AuthEvents {

    @EventListener
    public void onSuccess(AuthenticationSuccessEvent e) {
        log.info("LOGIN SUCCESS: {}", e.getAuthentication().getName());
    }

    @EventListener
    public void onFailure(AbstractAuthenticationFailureEvent e) {
        log.warn("LOGIN FAILURE: {}", e.getAuthentication().getName());
    }
}

Never Log

‚ùå Passwords
‚ùå Tokens
‚ùå Secrets

8. Security Testing with OWASP ZAP
Notes

Automated security testing tool

Finds XSS, SQL injection, misconfigurations

Common Tests

Broken authentication

Missing headers

CORS misconfig

Injection vulnerabilities

How to Use

Start app locally

Run OWASP ZAP

Use Automated Scan

Scan http://localhost:8080

Fix Examples
Missing Headers
http.headers(headers ->
    headers.xssProtection(Customizer.withDefaults())
);

Insecure Endpoints
@PreAuthorize("isAuthenticated()")

CI Integration

Run ZAP baseline scan

Fail build if high-risk issues found

Final Architecture Summary
Client
  ‚Üì
JWT Filter ‚Üí Rate Limiter ‚Üí Authorization
  ‚Üì
Method Security
  ‚Üì
Controller ‚Üí Service ‚Üí DB